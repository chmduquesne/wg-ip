#!/bin/bash
# Usage
#
# Generate an ip
# wg-ip [-4|-6] [--subnet <subnet>] gen <key>
#
# Generate and assign an ip for the specified interface, and for each
# peer, generate an ip and add it to allowed-ips
# wg-ip [-4|-6] [--subnet <subnet>] apply [dev <interface>]
#
# Like apply, but don't actually apply the changes (default action)
# wg-ip [-4|-6] [--subnet <subnet>] dryrun [dev <interface>]

fatal(){
    echo "$@" > /dev/stderr
    exit 1
}

expand_ipv6() {
  ip=$1

  # prepend 0 if we start with :
  grep -qs "^:" <<< $ip && ip="0${ip}"

  # expand ::
  if grep -qs "::" <<< "$ip"; then
    colons=$(sed 's/[^:]//g' <<< "$ip")
    missing=$(sed "s/$colons//" <<< :::::::::)
    expanded=$(sed 's/:/:0/g' <<< $missing)
    ip=$(sed "s/::/$expanded/" <<< $ip)
  fi

  blocks=$(grep -o "[0-9a-f]\+" <<< "$ip")
  set $blocks

  printf "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n" \
    $(( 16#$1 )) \
    $(( 16#$2 )) \
    $(( 16#$3 )) \
    $(( 16#$4 )) \
    $(( 16#$5 )) \
    $(( 16#$6 )) \
    $(( 16#$7 )) \
    $(( 16#$8 ))
}

test_expand_ipv6(){
  tests="2001:db8::2:1        2001:0db8:0000:0000:0000:0000:0002:0001 \
         2001:db8:0:1:1:1:1:1 2001:0db8:0000:0001:0001:0001:0001:0001 \
         2001:db8::1:0:0:1    2001:0db8:0000:0000:0001:0000:0000:0001 \
         2001:db8::1          2001:0db8:0000:0000:0000:0000:0000:0001 \
         ::                   0000:0000:0000:0000:0000:0000:0000:0000 \
         ::1                  0000:0000:0000:0000:0000:0000:0000:0001 \
         1::                  0001:0000:0000:0000:0000:0000:0000:0000"
  set $tests
  status=0
  while (( "$#" )); do
    printf "."
    res="$(expand_ipv6 $1)"
    if [ $res != "$2" ]; then
      echo "expand_ipv6 $1: expected $2, got $res"
      status=1
    fi
    shift 2
  done
  return $status
}

compress_ipv6() {
  ip=$1

  blocks=$(grep -o "[0-9a-f]\+" <<< "$ip")
  set $blocks

  # compress leading zeros
  ip=$(printf "%x:%x:%x:%x:%x:%x:%x:%x\n" \
    $(( 16#$1 )) \
    $(( 16#$2 )) \
    $(( 16#$3 )) \
    $(( 16#$4 )) \
    $(( 16#$5 )) \
    $(( 16#$6 )) \
    $(( 16#$7 )) \
    $(( 16#$8 ))
  )

  # prepend : for easier matching
  ip=:$ip

  # :: must compress the longest chain
  for pattern in :0:0:0:0:0:0:0:0 \
           :0:0:0:0:0:0:0 \
           :0:0:0:0:0:0 \
           :0:0:0:0:0 \
           :0:0:0:0 \
           :0:0; do
    if grep -qs $pattern <<< $ip; then
      ip=$(sed "s/$pattern/::/" <<< $ip)
      # if the substitution occured before the end, we have :::
      ip=$(sed 's/:::/::/' <<< $ip)
      break # only one substitution
    fi
  done

  # remove prepending : if necessary
  grep -qs "^:[^:]" <<< $ip && ip=$(sed 's/:\(.*\)/\1/g' <<< $ip)

  echo $ip
}

test_compress_ipv6(){
  tests="2001:0db8:0000:0000:0000:0000:0002:0001 2001:db8::2:1        \
         2001:0db8:0000:0001:0001:0001:0001:0001 2001:db8:0:1:1:1:1:1 \
         2001:0db8:0000:0000:0001:0000:0000:0001 2001:db8::1:0:0:1    \
         2001:0db8:0000:0000:0000:0000:0000:0001 2001:db8::1          \
         0000:0000:0000:0000:0000:0000:0000:0000 ::                   \
         0000:0000:0000:0000:0000:0000:0000:0001 ::1                  \
         0001:0000:0000:0000:0000:0000:0000:0000 1::                 "
  set $tests
  status=0
  while (( "$#" )); do
    printf "."
    res="$(compress_ipv6 $1)"
    if [ $res != "$2" ]; then
      echo "compress_ipv6 $1: expected $2, got $res"
      status=1
    fi
    shift 2
  done
  return $status
}

is_ipv6(){
  expanded="$(expand_ipv6 $1)"
  [ "$1" == "$expanded" ] && return 0
  compressed="$(compress_ipv6 $expanded)"
  [ "$1" == "$compressed" ] && return 0
  return 1
}

test_is_ipv6(){
  tests="2001:db8::2:1        0 \
         2001:db8:0:1:1:1:1:1 0 \
         2001:db8::1:0:0:1    0 \
         2001:db8::1          0 \
         ::                   0 \
         ::1                  0 \
         1::                  0 \
         2001:db8::0:1        1 \
         2001:db8::1:1:1:1:1  1 \
         2001:db8:0:0:1::1    1 \
         2001:DB8::1          1"
  set $tests
  status=0
  while (( "$#" )); do
    printf "."
    is_ipv6 $1
    res=$?
    if [ "$res" != "$2" ]; then
      echo "is_ipv6 $1: expected $2, got $res"
      status=1
    fi
    shift 2
  done
  return $status
}

is_ipv4(){
  grep -qs "[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}" <<< $1 \
    || return 1
  for i in $(grep -o "[0-9]\+" <<< $1); do
    if [ "$i" -gt 255 ]; then
      return 1
    fi
  done
  return 0
}

test_is_ipv4(){
  tests="4.2.2.2          0 \
         192.168.1.1      0 \
         0.0.0.0          0 \
         255.255.255.255  0 \
         192.168.0.1      0 \
         a.b.c.d          1 \
         255.255.255.256  1 \
         192.168.0        1 \
         1234.123.123.123 1"
  set $tests
  status=0
  while (( "$#" )); do
    printf "."
    is_ipv4 $1
    res=$?
    if [ "$res" != "$2" ]; then
      echo "is_ipv4 $1: expected $2, got $res"
      status=1
    fi
    shift 2
  done
  return $status
}

netmask_bytes(){
  netmask=$1
  len=$2

  res=""
  for i in $(seq 0 $(( $len - 1 )) ); do
    b=0
    for j in $(seq 0 7); do
      if [ $(( 8 * $i + $j )) -lt $netmask ]; then
        b=$(( $b | 1 << (7 - $j) ))
      fi
    done
    res="$res $b"
  done
  echo $res
}

test_netmask_bytes(){
  status=0
  printf "."
  if [ "$(netmask_bytes 8 4)" != "255 0 0 0" ]; then
    echo "netmask_bytes 8 4: FAIL"
    status=1
  fi
  printf "."
  if [ "$(netmask_bytes 9 4)" != "255 128 0 0" ]; then
    echo "netmask_bytes 8 4: FAIL"
    status=1
  fi
  return $status
}

# key [subnet]
gen_ipv6(){
  pubkey=$1
  subnet=$2

  prefix=$(cut -d/ -f1 <<< $subnet)
  if ! is_ipv6 $prefix; then
    fatal "$prefix: not a valid ipv6 address"
  fi
  prefix=$(expand_ipv6 $prefix)

  netmask=$(cut -d/ -f2 <<< $subnet)
  if [ "$netmask" -le 0 -o "$netmask" -ge 128 ]; then
    fatal "$netmask: invalid netmask"
  fi

  pubkeychecksum=$(sha256sum <<< $pubkey)
  genbytes=( $(grep -o "[0-9a-f]\{2\}" <<< $pubkeychecksum) )
  netbytes=( $(grep -o "[0-9a-f]\{2\}" <<< $prefix) )

  maskbytes=( $(netmask_bytes $netmask 16) )

  bytes=""
  for i in $(seq 0 15); do
    m=${maskbytes[$i]}
    m_flipped=$(( $m ^ 16#ff ))
    b=$(( (16#${netbytes[$i]} & $m) | (16#${genbytes[$i]} & $m_flipped) ))
    bytes="$bytes $b"
  done

  printf "%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x\n" \
    $bytes

}

test_gen_ipv6() {
  tests="foo fd1a:6126:2887::/48 fd1a:6126:2887:f9b1:d61e:21e7:96d7:8dcc \
         bar fd1a:6126:2887::/48 fd1a:6126:2887:6691:8c98:63af:ca94:2d0f \
         foo fd1a:6126:2887::/49 fd1a:6126:2887:79b1:d61e:21e7:96d7:8dcc \
         bar fd1a:6126:2887::/49 fd1a:6126:2887:6691:8c98:63af:ca94:2d0f \
         foo 2001:db8::/64       2001:0db8:0000:0000:d61e:21e7:96d7:8dcc \
         bar 2001:db8::/64       2001:0db8:0000:0000:8c98:63af:ca94:2d0f"
  set $tests
  status=0
  while (( "$#" )); do
    printf "."
    res="$(gen_ipv6 $1 $2)"
    if [ "$res" != "$3" ]; then
      echo "gen_ipv6 $1 $2: expected $3, got $res"
      status=1
    fi
    shift 3
  done
  return $status
}

# key [subnet]
gen_ipv4(){
  pubkey=$1
  subnet=$2

  prefix=$(cut -d/ -f1 <<< $subnet)
  if ! is_ipv4 $prefix; then
    fatal "$prefix: not a valid ipv4 address"
  fi

  netmask=$(cut -d/ -f2 <<< $subnet)
  if [ "$netmask" -le 0 -o "$netmask" -ge 32 ]; then
    fatal "$netmask: invalid netmask"
  fi

  pubkeychecksum=$(sha256sum <<< $pubkey)
  genbytes=( $(grep -o "[0-9a-f]\{2\}" <<< $pubkeychecksum) )
  netbytes=( $(grep -o "[0-9]\+" <<< $prefix) )

  maskbytes=( $(netmask_bytes $netmask 4) )

  bytes=""
  for i in $(seq 0 3); do
    m=${maskbytes[$i]}
    m_flipped=$(( $m ^ 16#ff ))
    b=$(( (${netbytes[$i]} & $m) | (16#${genbytes[$i]} & $m_flipped) ))
    bytes="$bytes $b"
  done

  printf "%d.%d.%d.%d\n" \
    ${bytes[@]}

}

test_gen_ipv4() {
  tests="foo 10.0.0.0/8    10.187.157.128 \
         bar 10.0.0.0/8    10.134.94.149 \
         foo 10.0.0.0/9    10.59.157.128 \
         bar 10.0.0.0/9    10.6.94.149
         foo 172.16.0.0/12 172.27.157.128 \
         bar 172.16.0.0/12 172.22.94.149"
  set $tests
  status=0
  while (( "$#" )); do
    printf "."
    res="$(gen_ipv4 $1 $2)"
    if [ "$res" != "$3" ]; then
      echo "gen_ipv4 $1: expected $3, got $res"
      status=1
    fi
    shift 3
  done
  return $status
}

configure_interface_ipv6(){
  iface=$1
  pubkey=$(wg show $iface public-key)
  ip=$(gen_ipv6 $pubkey $subnet6)
  echo ip addr add fd1a:6126:2887:6171:2283:b30f:5119:b72b dev wg0
  for peer in $(wg show $iface peers); do
    allowed_ips=$(wg show $iface allowed-ips | grep $peer | cut -f2 | tr " " ",")
    ip=$(gen_ipv6 $pubkey $subnet6)
    if [ "$allowed_ips" != "" ]; then
      allowed_ips=$allowed_ips,$ip/128
    else
      allowed_ips=$ip/128
    fi
    echo "wg set wg0 peer $peer allowed-ips $allowed_ips"
  done
}

runtests() {
  script=$(readlink -f $0)
  testfuncs=$(grep "^test_.*()" $script | sed 's/().*$//g')
  for i in $testfuncs; do
    printf "%s" $i
    if $i; then
      echo PASS
    else
      echo FAIL
    fi
  done
}

# default values
subnet4="10.0.0.0/8"
subnet6="fd1a:6126:2887::/48"
mode="ipv6"
ipbits=128
device=""
pubkey=""

while [ "$#" != 0 ];
do
  case "$1" in
    --test)
      runtests
      exit
      ;;
    -4)
      mode="ipv4"
      ipbits=32
      shift
      ;;
    -6)
      mode="ipv6"
      ipbits=128
      shift
      ;;
    --subnet)
      shift
      subnet=$1
      prefix=$(cut -d/ -f1 <<< $subnet)
      if [ "$mode" == "ipv4" ]; then
        if is_ipv4 $prefix; then
          subnet4=$subnet
        else
          fatal "$1: not a valid ipv4 subnet"
        fi
      else
        if is_ipv6 $prefix; then
          subnet6=$subnet
        else
          fatal "$1: not a valid ipv4 subnet"
        fi
      fi
      netmask=$(cut -d/ -f2 <<< $subnet)
      if [ "$netmask" -le 0 -o "$netmask" -ge "$ipbits" ]; then
        fatal "$netmask: not a valid $mode netmask"
      fi
      shift
      ;;
    gen)
      if [ "$action" != "" ]; then
        fatal "only one command is possible"
      else
        action=gen
      fi
      shift
      pubkey="$1"
      shift
      ;;
    dev)
      shift
      device=$1
      shift
      ;;
    *)
      fatal "$1: invalid argument"
      shift
      ;;
  esac
done

[ "$action" == "" ] && action=dryrun

case "$action" in
  gen)
    if [ "$mode" == "ipv6" ]; then
      gen_ipv6 "$pubkey" "$subnet6"
    else
      gen_ipv4 "$pubkey" "$subnet4"
    fi
    ;;
  dryrun)
    if [ $UID !=0 ]; then
      fail "this command requires root access"
    fi
    if [ "$device" = "" ]; then
      for iface in $(wg show interfaces); do
        echo $iface
      done
    fi
    ;;
esac
